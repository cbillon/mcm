#!/bin/bash

RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELOW=$(tput setaf 3)
BLUE=$(tput setaf 14)
NC=$(tput sgr 0)

function info() { [ "$DEBUG" = false ] && echo "${BLUE}${@} ${FUNCNAME[1]}${NC}" || echo "${BLUE}${@} ${FUNCNAME[1]} line:${BASH_LINENO[0]}${NC}"; }
function warn() { [ "$DEBUG" = false ] && echo "${YELOW}${@} ${FUNCNAME[1]}${NC}" || echo "${YELOW}${@} ${FUNCNAME[1]} line:${BASH_LINENO[0]}${NC}"; }
function error() { [ "$DEBUG" = false ] && echo "${RED}${@} ${FUNCNAME[1]}${NC}" || echo "${RED}${@} ${FUNCNAME[1]} line:${BASH_LINENO[0]}${NC}"; }
function success() { [ "$DEBUG" = false ] && echo "${GREEN} ${FUNCNAME[1]}${@}${NC}" || echo "${GREEN}${@} ${FUNCNAME[1]} line:${BASH_LINENO[0]}${NC}"; }

function check_command() {
  if [[ $? -ne 0 ]]; then
    error "Error execution ${FUNCNAME[1]} line:${BASH_LINENO[0]} command: ${@}"
    exit 1
  fi
}

function get_pluglist () {
  info Start
  error=0
  local diff now loadfile
  loadfile=false
  if [ -f "$SCRIPT_DIR"/pluglist.json ]; then
    now=$(date +'%Y-%m-%d')
    [[ $(stat "$SCRIPT_DIR"/pluglist.json | grep -E ^.*Modify:.*$) =~ ^.*Modify:.([0-9]{4}-[0-9]{2}-[0-9]{2}).*$ ]] && filedate="${BASH_REMATCH[1]}"
    let diff=$(date +%s -d "$now")-$(date +%s -d "$filedate")
    let diff="$diff"/86400
    [ "$DEBUG" = true ] && info Diff days: $diff  
    [[ $diff -gt "$DIFF_DAYS" ]] && loadfile=true
  else  
    [ "$DEBUG" = true ] && info load file "$SCRIPT_DIR"/pluglist.json: "$loadfile"
    loadfile=true
  fi 
  
  [[ $"$loadfile" = true ]] && wget download.moodle.org/api/1.3/pluglist.php -O "$SCRIPT_DIR"/pluglist.json
  
  info End
  return "$error"
}

function load_cnf () {  
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  PROJECT_BRANCH="$PROJECT"
  [ "$DEBUG" = true ] && info Start  "$PROJECT"/"$PROJECT_BRANCH" 
  [ -f "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml ] || check_command "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml non défini
  yq . "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml >/dev/null
  [ $? -eq 1 ]&& error Erreur syntaxe fichier configuration du projet&&error Fichier configuration "${PROJECTS_PATH_PROJECT}"/"$PROJECT".yml incorrect&&return 1 
 
  MOODLE_VERSION=$(yq .moodle.version "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  MOODLE_MAJOR_VERSION="${MOODLE_VERSION:0:3}"
  # la branche de la version MOODLE majeure est obtenue par moodle-version.yml
  MOODLE_BRANCH=$(yq '."'${MOODLE_MAJOR_VERSION}'".branch' "$RACINE"/moodle-version.yml)
  if [[ "$MOODLE_BRANCH" != null  ]]; then
    [ "$DEBUG" = true ] && info "Moodle: $MOODLE_MAJOR_VERSION Branch: $MOODLE_BRANCH" 
  else
    error "Version ${MOODLE_MAJOR_VERSION} non définie dans moodle-version.yml" 
    error=1    
  fi
  
  # ne fonctione pas si "$MOODLE_SRC"  exieste mais n' aps la branche major Moodle
  # if [ -d "$MOODLE_SRC" ];then
  #   cd  "$MOODLE_SRC"|| exit 1    
  #   if [ -f "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current ]; then
  #     old_moodle_current=$(cat "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current)
  #     get_moodle_current "$MOODLE_VERSION" || check_comma
# echo "Recopie config.php depuis $PROJECTS_PATH"/"$PROJECT/config-php/config.php"   
#   cp "$PROJECTS_PATH"/"$PROJECT"/config-php/config.php "$PROJECTS_PATH"/"$PROJECT"/releases/"$NEWRELEASE"/
# elif [ -e "$PROJECTS_PATH"/"$PROJECT"/current/config.php ];  then
#   echo "Recopie config.php depuis derniere release $PROJECTS_PATH"/"$PROJECT/current/config.php si elle existe"
#   cp $PROJECTS_PATH"/"$PROJECT/current/config.php "$PROJECTS_PATH"/"$PROJECT"/releases/"$NEWRELEASE"
#   #et aussi  sauvegarde 
#   cp $PROJECTS_PATH"/"$PROJECT/current/config.php $PROJECTS_PATH"/"$PROJECT/config-php/
# fi

#   info End

# }nd Error get_moodle_current "$MOODLE_VERSION"        
  #     if [ "$old_moodle_current" != "$MOODLE_CURRENT" ]; then
  #        warning MOODLE_CURRENT "$old_moodle_current" has changed "new_moodle_current"
  #     fi
  #   fi
  # fi
  
  [ "$DEBUG" = true ] && info End
   return "$error"
}

function create_file () {
  error=0
  [ -z "$1" ]&& error project param missing && exit
  if [ ! -f "$1" ];then
    touch "$1"
  fi
}

function create_dir () {
  error=0
  [ -z "$1" ]&& error project param missing && exit
  if [ ! -d "$1" ];then
    mkdir -p "$1"
  fi
}

function verif_pre_requis () {
  info Start 
  local error
  error=0
  git --version || error=1  
  jq --version || error=1
  yq --version || error=1
  [ "$error" -eq 0 ] && success Pre requis satisfied || error Pre requis not satisfied

  info End
  return "$error"
}

function create_env () {
  
  info Start
  # Initialisation signal erreur PROJECT_PATH
  error=0
  
  create_dir "$DEPOT_MODULES"
  create_dir "$PROJECTS_PATH" 
  create_file save.var
  # création projet demo
  
  PROJECT='demo'

  info End   
}

function new_project () {
  
  info Start 
  # Initialisation signal erreur PROJECT_PATH
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  
  [[ -d "$PROJECTS_PATH"/"$PROJECT" ]] && warn "Project $PROJECT already exist !" && exit 1

  info Creation environment "$PROJECTS_PATH"/"$PROJECT"
  
  #create_dirs
  
  create_dir "$PROJECTS_PATH"/"$PROJECT"
  create_dir "$PROJECTS_PATH"/"$PROJECT"/env 
  create_file "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
  create_file "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current
  create_file "$PROJECTS_PATH"/"$PROJECT"/save.moodle_branch

  echo "# Configuration de $PROJECT" >>  "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
  echo "# generatedlist_plugin_cache by $USER $DATE_DU_JOUR" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml 
  
  MOODLE_VERSION=$(whiptail --inputbox "What is your Moodle version?" 8 39 --title "Conf $PROJECT" $MOODLE_VERSION 3>&1 1>&2 2>&3)
  echo "moodle:" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
  echo "  version: $MOODLE_VERSION" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
  MOODLE_MAJOR_VERSION="${MOODLE_VERSION:0:3}"
  # la branche de la version MOODLE majeure est obtenue par moodle-version.yml
  MOODLE_BRANCH=$(yq '."'${MOODLE_MAJOR_VERSION}'".branch' "$RACINE"/moodle-version.yml)
  if [[ "$MOODLE_BRANCH" != null  ]]; then
    [ "$DEBUG" = true ] && echo "Moodle ${MOODLE_MAJOR_VERSION} Branch: $MOODLE_BRANCH" 
    echo "$MOODLE_BRANCH" > "$PROJECTS_PATH"/"$PROJECT"/save.moodle_branch
  else
    error "Version ${MOODLE_MAJOR_VERSION} non définie dans moodle-version.yml" 
    exit   
  fi
  PROJECT_BRANCH="$PROJECT"

  echo "" >>"$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
  echo "plugins:" >>"$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
      
  create_dir "$PROJECTS_PATH"/"$PROJECT"/env/dev
  create_file "$PROJECTS_PATH"/"$PROJECT"/env/dev/config.php$MOODLE_BRANCHl ok
  DEPOT_ORIGIN="$MOODLE_HQ"
  create_project_repo "$PROJECT"
   
  success "Project environment $PROJECT created"
  info End
}

function get_moodle_current () {
  info Start 
  # Initialisation signal erreur 
  error=0
  [ -z "$1" ]&& error project param MOODLE_VERSION missing && exit
  MOODLE_VERSION="$1"
  MOODLE_MAJOR_VERSION="${MOODLE_VERSION:0:3}"
  # la branche de la version MOODLE majeure est obtenue par moodle-version.yml
  MOODLE_BRANCH=$(yq '."'${MOODLE_MAJOR_VERSION}'".branch' "$RACINE"/moodle-version.yml)
  if [[ "$MOODLE_BRANCH" != null  ]]; then
    [ "$DEBUG" = true ] && echo "Moodle: $MOODLE_MAJOR_VERSION Branch: $MOODLE_BRANCH" 
  else
    error "Version ${MOODLE_MAJOR_VERSION} non définie dans moodle-version.yml" 
    error=1   
    exit 
  fi
  cd "$MOODLE_SRC" || exit 1
  [ "$DEBUG" = true ] && info MOODLE_VERSION: "$MOODLE_VERSION"
  if [[ "$MOODLE_VERSION" =~ ^4\.[0-5]$ ]]
  then
  #for example 4.5
    [ "$DEBUG" = true ] && info "Latest available release $MOODLE_VERSION"    
    echo "latest available release $MOODLE_VERSION"
    tags=$(git tag -l v"$MOODLE_VERSION"?)
    [ -z $tags ] && error Tags are missing!  && exit 1
    info $tags    
    MOODLE_CURRENT=v${tags##*v}    
  elif [[ "$MOODLE_VERSION" =~ ^4\.[0-5]\+$ ]]
  then
    #for example 4.5+
    [ "$DEBUG" = true ] && info "latest available release with fixes $MOODLE_VERSION"    
    git checkout "$MOODLE_BRANCH" --quiet || check_command Error git checkout "$MOODLE_BRANCH"
    MOODLE_CURRENT="$MOODLE_BRANCH"
  elif [[ "$MOODLE_VERSION" =~ ^4\.[0-5]\.[0-4]$ ]]
  then
    #for example 4.5.1
    [ "$DEBUG" = true ] && info "Specific release in $MOODLE_VERSION"    
    
    [[ $(git tag -l "v${MOODLE_VERSION}") ]] || (error "Release $MOODLE_VERSION not exists" && exit 1)   
    MOODLE_CURRENT=v$MOODLE_VERSION
  elif [[ "$MOODLE_VERSION" =~ ^4\.[0-5]\.[0-4]\+$ ]]
  then
    error specific release with fixes in "$MOODLE_VERSION" not yet supoorted...&& error=1
  else
    error Valeur incorrecte "$MOODLE_VERSION" && error=1
  fi 

  if [ "$error" -eq 0 ]; then
    if [ ! -f "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current ]; then
      create_file "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current
      echo "$MOODLE_CURRENT" > "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current
    else
      old_moodle_current=$(cat "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current)           
      if [ ! -z "$old_moodle_current" ] && [ "$old_moodle_current" != "$MOODLE_CURRENT" ]; then
        warn MOODLE_CURRENT "$old_moodle_current" has changed "$MOODLE_CURRENT"
      fi
    fi

    # verify 
    git checkout "$MOODLE_CURRENT" || check_command Error git checkout "$MOODLE_CURRENT"
  fi
  info "MOODLE_CURRENT: $MOODLE_CURRENT"

  info End
  return "$error"
}


function create_project_repo () {

  info Start 
  # Initialisation signal erreur 
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  load_cnf "$PROJECT" || exit 1
  [ "$DEBUG" = true ] && info MOODLE_BRANCH: "$MOODLE_BRANCH"
  if [ -d $MOODLE_SRC ]; then
    info "$MOODLE_SRC" already exists!
    cd "$MOODLE_SRC" || exit 1

    if [[ ! $(git branch --list | grep "^.*$MOODLE_BRANCH") ]]; then
      info "Branch $MOODLE_BRANCH not exists create branch"
      git remote set-branches upstream "$MOODLE_BRANCH" || check_command "Error git remote set-branches upstream $MOODLE_BRANCH"
      git fetch upstream "$MOODLE_BRANCH" --tags || check_command "Error git fetch upsteam $MOODLE_BRANCH"
      git branch "$MOODLE_BRANCH" upstream/"$MOODLE_BRANCH" || check_command "Error git branch $MOODLE_BRANCH upstream/$MOODLE_BRANCH"
      git fetch --tags upstream/"$MOODLE_BRANCH" || check_command Error git fetch --tags upstream/"$MOODLE_BRANCH"
    fi

  else 
    info "$MOODLE_SRC" does not exists
    if [ -z ${MOODLE_DEPTH+x} ]; then
     info "MOODLE_DEPTH" is unset
     echo "Recopie config.php depuis $PROJECTS_PATH"/"$PROJECT/config-php/config.php"   
     git clone --branch "$MOODLE_BRANCH" "$DEPOT_ORIGIN"  "$MOODLE_SRC" || check_command "Error git clone --branch $MOODLE_BRANCH $DEPOT_ORIGIN  $MOODLE_SRC"
    else 
      info "MOODLE_DEPTH is set to $MOODLE_DEPTH"
      git clone --depth="$MOODLE_DEPTH" --branch "$MOODLE_BRANCH" "$DEPOT_ORIGIN"  "$MOODLE_SRC" || check_command Error git clone "$MOODLE_BRANCH" "$DEPOT_ORIGIN" "$MOODLE_SRC"
    fi
        
    cd $MOODLE_SRC || exit 1
    
    if [ $DEPOT_ORIGIN == $MOODLE_HQ ]; then
      info rename upstream $MOODLE_SRC
      git remote rename origin upstream
      [ $? -ne 0 ] && error=1 &&  error git remote rename origin upstream && exit 1      
    else
      git remote add upstream "$MOODLE_HQ" || check_command Error git remote add origin "$MOODLE_HQ"         
    fi
  fi
  
  #
  #PROJECT_BRANCH="$PROJECT"
  # création de la branch projet
  cd "$MOODLE_SRC" || exit 1
  
  get_moodle_current "$MOODLE_VERSION"

  if [[ "$(git branch)" =~ ^.*"$PROJECT_BRANCH" ]]; then
    git checkout "$PROJECT_BRANCH" --quiet || check_command "Error git checkout $PROJECT_BRANCH"
  else
    info "Create Branch $PROJECT_BRANCH from $MOODLE_CURRENT"
    git branch "$PROJECT_BRANCH" "$MOODLE_CURRENT" || check_command "Error git branch $PROJECT_BRANCH from $MOODLE_CURRENT"          
  fi
  
  git checkout "$PROJECT_BRANCH" --quiet || check_command "Error git checkout $PROJECT_BRANCH"   
  
  info End

}

function update_moodle () {
info Start 
# Initialisation signal erreur 
error=0
#exec 1> >(logger -s -t $(basename $0)) 2>&1
[ -z "$1" ]&& error project param PROJECT missing && exit
PROJECT="$1"
load_cnf $PROJECT || exit 1
# determine Moodle release before update
get_moodle_current "$MOODLE_VERSION"
echo "$MOODLE_CURRENT" > "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current
cd "$MOODLE_SRC" || exit
git checkout "$MOODLE_CURRENT" --quiet || error check_command git checkout "$MOODLE_CURRENT"
commit_before=$(git rev-parse --short HEAD)

[ "$DEBUG" = true ] && info MOODLE_CURRENT: "$MOODLE_CURRENT"
[ "$DEBUG" = true ] && echo "Parametres:"
[ "$DEBUG" = true ] && echo "  Projet: $PROJECT"
[ "$DEBUG" = true ] && echo "  Version Moodle: $MOODLE_VERSION"
[ "$DEBUG" = true ] && echo "  Branche Moodle: $MOODLE_BRANCH"
[ "$DEBUG" = true ] && echo "  Depot local: $MOODLE_SRC"
[ "$DEBUG" = true ] && echo "  Branche local projet: $PROJECT_BRANCH"
[ "$DEBUG" = true ] && echo "  Moodle courant : $MOODLE_CURRENT"
[ "$DEBUG" = true ] && echo "  Mise à jour depot remote : $MOODLE_UPDATE_ORIGIN" 
# valeur MOODLE_UPDATE_ORIGIN definie dans <nom du PROJECT>.yml

cd "$MOODLE_SRC" || exit 1

echo "Mise à jour $MOODLE_BRANCH depuis upstream"

if [ -z ${MOODLE_DEPTH+x} ]; then
  info "MOODLE_DEPTH" is unset
  git fetch upstream "$MOODLE_BRANCH" --tags --quiet || check_command Error git fetch upstream "$MOODLE_BRANCH"
else 
  info "MOODLE_DEPTH is set to $MOODLE_DEPTH"
  git fetch upstream "$MOODLE_BRANCH" --quiet || check_command Error git fetch upstream "$MOODLE_BRANCH"
fi

info "Fetch upstream $MOODLE_BRANCH effectuée"
remote_branch=$(git log -n 1 --pretty=format:"%H" upstream/"$MOODLE_BRANCH")
local_branch=$(git log -n 1 --pretty=format:"%H" "$MOODLE_BRANCH")

if [[ "$remote_branch" !=  "$local_branch" ]]; then
  git checkout "$MOODLE_CURRENT" --quiet || check_command "git checkout $MOODLE_CURRENT"
  git merge --ff-only  upstream/"$MOODLE_BRANCH" || check_command "git merge --ff-only  upstream/$MOODLE_BRANCH "
  info Mise jour "$MOODLE_BRANCH" local depuis upstream/"$MOODLE_BRANCH" effectuée.
fi  

get_moodle_current "$MOODLE_VERSION"
echo "$MOODLE_CURRENT" > "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current
cd "$MOODLE_SRC" || exit
git checkout "$MOODLE_CURRENT" --quiet || error check_command git checkout "$MOODLE_CURRENT"
commit_after=$(git rev-parse --short HEAD)

if [[ "$commit_after" != "$commit_before" ]]; then
  git checkout "$PROJECT_BRANCH" --quiet || check_command Error git checkout "$PROJECT_BRANCH"
  git merge "$MOODLE_CURRENT" || check_command Error git merge "$MOODLE_CURRENT"
  get_moodle_current "$MOODLE_VERSION"
  echo "$MOODLE_CURRENT" > "$PROJECTS_PATH"/"$PROJECT"/save.moodle_current
  info "$PROJECT_BRANCH" merged after Moodle update
else
  info No change on project Moodle version
fi

success "$FUNCNAME successfully ended" 

}

function list_plugin_cache () {

  info Start 
  error=0
  i=0
  list=''
  for d in $(ls -l "$DEPOT_MODULES" | grep ^.*moodle-.* | awk '{print $9}' | sort); do
    i=$((i+1))
    list=/modules/moodle-tool_redis"$list $i $d"
  done
    
  parm=$(whiptail --title "Plugins cache" --menu "Plugin's List(cache)" 25 78 16 $list 3>&1 1>&2 2>&3)
  sortie=0
  info End
}

function add_plugin_cache () {
  
  info Start 
  error=0
  [ -z "$1" ]&& PLUGIN="$1" || PLUGIN="moodle-"
  parm=$(whiptail --inputbox "New plugin?" 8 39 "$PLUGIN" --title "Add plugin" 3>&1 1>&2 2>&3)
  # A trick to swap stdout and stderr.
  # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
  exitstatus=$?

  if [ $exitstatus -ne 0 ]; then    
    error "Select canceled."
    exit 
  fi
  # en parametre le plugin recherché sous la forme moodle-<type>_<name>
  # ou abbrégée  <type>_<name
  
  [ -z $parm ] && error "$parm" Parametre plugin missing && exit
  [[ "$parm" =~ ^moodle-(.*)$ ]] && component_name="${BASH_REMATCH[1]}" || component_name="$parm"
  PLUGIN='moodle-'"$component_name"
  [ "$DEBUG" = true ] && info Import: "$PLUGIN"
  if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then
    warn "$PLUGIN" already exists    
  else
    if [[ "$PLUGIN" =~ ^moodle-([a-z]*)_(.*)$ ]]; then
      type="${BASH_REMATCH[1]}"
      [ "$DEBUG" = true ] && info type: "$type"
      name="${BASH_REMATCH[2]}"
      [ "$DEBUG" = true ] && info name: "$name"
      dir=$(jq -r .plugintypes.${type} "$SCRIPT_DIR"/types.json)
      if [ "$dir" == null ]; then
        error type: "$type" invalide
        exit    
      fi   
    else
      error "syntax error must be [moodle-]<type>_<name>"
      exit
    fi
  
    # Recherche dans le fichier de référence
  
    jq -r --arg plugin  "$component_name" '.plugins| map(select(.component == $plugin)) | .[]' "$SCRIPT_DIR"/pluglist.json > "$RACINE"/tmp.json
    var=$(jq '.id' "$RACINE"/tmp.json)
    if [ "$var" == '' ]; then
      error "$component_name" not found in plugin directory
      exit
    fi
    NAME=$(jq -r '.name' "$RACINE"/tmp.json)
    SOURCE=$(jq -r '.source' "$RACINE"/tmp.json)  
    [[ $SOURCE  =~ ^.*\/\/.*\/.*\/(.*)$ ]] && info Plugin: "${BASH_REMATCH[1]}"
  
    # Add plugin 
    info Source: "$SOURCE"
    if [[ ! $SOURCE ]]; then 
      error "$PLUGIN" non trouvé
      SOURCE=$(whiptail --inputbox "Source du plugin?" 8 39 "https://github.com//$PLUGIN" --title "Project" 3>&1 1>&2 2>&3)
    # A trick to swap stdout and stderr.
    # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
      exitstatus=$?
      if [ $exitstatus -ne 0 ]; then    
        error "Select canceled."
        exit 1 
      fi    
      info Source du plugin "$PLUGIN":"$SOURCE"
    fi

    cd "$DEPOT_MODULES" || exit
    git clone "$SOURCE" $PLUGIN --quiet || check_command Error "$?" git clone "$SOURCE" "$PLUGIN"
    cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
    git remote rename origin upstream || check_command Error git remote rename origin  upstream
    
  fi
success "$PLUGIN locally loaded in cache"
info End

}

function add_plugin_project () {
  info Start 
  edit=0
  cd "$MOODLE_SRC" || exit 1
  git checkout "$PROJECT_BRANCH" --quiet || (error git checkout "$PROJECT_BRANCH" && exit 1)
  PLUGINS=$(yq 'select(.plugins) |.plugins|keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)

  cd "$DEPOT_MODULES" || exit
  i=0
  list=''
  for d in $(ls -l "$DEPOT_MODULES" | grep ^.*moodle-.* | awk '{print $9}'); do
    [[ "$PLUGINS" =~ .*"$d".* ]] && continue
    i=$((i+1))
    list="$list $d $i OFF"
  done

  PLUGINS=$(whiptail --title "Plugins cache" --checklist "Plugin's List" 25 78 16 $list 3>&1 1>&2 2>&3)
  exitstatus=$?

  if [ $exitstatus -ne 0 ]; then    
    error "Select canceled."
    exit 1 
  fi

  for PLUGIN in $PLUGINS; do
    PLUGIN="${PLUGIN//'"'}" 
    # "'
    if [[ ! $(cat "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml) =~ ^.*"$PLUGIN".*$ ]]; then      
      cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
      [[ "$PLUGIN" =~ ^moodle-(.*)$ ]] && component_name="${BASH_REMATCH[1]}"
      jq -r --arg plugin  "$component_name" '.plugins| map(select(.component == $plugin)) | .[]' "$SCRIPT_DIR"/pluglist.json > "$RACINE"/tmp.json
      var=$(jq '.id' "$RACINE"/tmp.json)
      [ ! $var == '' ] && info "$var" || error nothing found
      NAME=$(jq -r '.name' "$RACINE"/tmp.json)
      SOURCE=$(jq -r '.source' "$RACINE"/tmp.json)  
      [[ $SOURCE  =~ ^.*\/\/.*\/.*\/(.*)$ ]] && info Plugin: "${BASH_REMATCH[1]}"
      if [[ ! "$SOURCE" ]]; then           
        url=$(cat .git/config | grep -E "^.*url.*$")
        [ "$DEBUG" = true ] && info url: "$url"
        [[ "$url"  =~ ^.*(https:.*)$ ]] && SOURCE="${BASH_REMATCH[1]}"
      fi
    
      echo "" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
      echo "  $PLUGIN:" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
      echo "    name: $NAME" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
      echo "    source: $SOURCE" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
      select_plugin_branch "$PROJECT" "$PLUGIN"
      echo "    branch: $PLUGIN_BRANCH" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml    
      edit=1  
    fi    
  done
  [ $edit == 1 ] && nano "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
  info End
}

function select_plugin_branch () {
  info Start 
  [ -z "$1" ]&& error project param PROJECT missing && exit
  [ -z "$1" ]&& error project param PLUGIN missing && exit
  PROJECT="$1"
  PLUGIN="$2"
  PLUGIN_BRANCH=''
  load_cnf "$1"

  cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1

  [ "$DEBUG" = true ] && info Branche Moodle: "$MOODLE_BRANCH"
  info "Plugin: $PLUGIN"

  local found
  found=false
  if [[ $(git branch -r | grep -E "^  upstream\/$MOODLE_BRANCH$") ]]; then
    PLUGIN_BRANCH="$MOODLE_BRANCH"
    info "Bingo Moodle branch $MOODLE_BRANCH match !"
    found=true
  else 
    branch_stable_remote=$(git branch -r | grep -E "^  upstream\/MOODLE_[0-9]{2,3}_STABLE$" | sort -rn | head -n 1)
    info "default best highest remote branch $branch_stable_remote"
    if [[ "$branch_stable_remote" ]]; then        
      if [[ $branch_stable_remote =~ ^.*upstream\/(.*)$ ]]; then
        PLUGIN_BRANCH="${BASH_REMATCH[1]}"
        found=true
      fi
    fi 
  fi
  
  if [ $found = false ]; then  
    if [[ $(git rev-parse --verify upstream/master 2>/dev/null) ]]; then      
      PLUGIN_BRANCH=master
      found=true
      info Branch remote master exists
    elif [[ $(git rev-parse --verify upstream/main 2>/dev/null) ]]; then      
      PLUGIN_BRANCH=main
      found=true
      info Branch remote main selectionnée
    fi
  fi
  
  if [ $found = true ]; then
    if [[ $(git rev-parse --verify "$PLUGIN_BRANCH" 2>/dev/null) ]]; then
     info "$PLUGIN_BRANCH selected exists"
    else 
      git branch "$PLUGIN_BRANCH" remotes/upstream/"$PLUGIN_BRANCH" --quiet || check_command Error  git branch "$PLUGIN_BRANCH" remotes/upstream/"$PLUGIN_BRANCH"
      info Branch upstream/"$PLUGIN_BRANCH" créée
    fi
  fi 
  [[ "$PLUGIN_BRANCH" != null ]]&& git checkout "$PLUGIN_BRANCH" --quiet
  info "$PLUGIN" branch: "$PLUGIN_BRANCH"
  info End
}

function config_check () {

  info Start "$FUNCNAME"
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  # check validity .yml 
  yq "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml >/dev/null  || exit 1
  
  PLUGINS=$(yq 'select(.plugins) |.plugins| keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS "$PLUGINS"
  for PLUGIN in $PLUGINS; do    
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    [[ "$PLUGIN" =~ ^\.*# ]] && continue
    info "Check plugin: $PLUGIN"
    SOURCE=$(yq .plugins."$PLUGIN".source "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)  
    BRANCH_UPSTREAM=$(yq .plugins."$PLUGIN".branch "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)  
    PLUGIN_VERSION=$(yq .plugins."$PLUGIN".version "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
    LOCALDEV=$(yq .plugins."$PLUGIN".localdev "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
    #if LOCALDEV not defined set to null
    if [[ "$PLUGIN_VERSION" != null ]]; then    
      BRANCH_PLUGIN="$PLUGIN_VERSION"
      [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN  from PLUGIN_VERSION not null: $PLUGIN_VERSION"
    elif [[ "$LOCALDEV" != 'null' ]]; then
      BRANCH_PLUGIN="$LOCALDEV"
      [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN from LOCALDEV not null: $LOCALDEV"
    elif [[ "$BRANCH_UPSTREAM" != 'null' ]]; then
      BRANCH_PLUGIN="$BRANCH_UPSTREAM"
      [ "$DEBUG" = true ] && echo "  BRANCH_UPSTREAM: $BRANCH_PLUGIN from plugin's branch: $BRANCH_UPSTREAM"
    else
      error Manque definition version "$PLUGIN"
      error=1
    fi      
  done
  
  [ "$error" -eq 0 ] && success Configuration file "$PROJECT" successful || error Please correct configuration file and retry
  
  info End
}

function edit_plugins () { 
  
  info Start 
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  load_cnf "$PROJECT" || exit 1
  PROJECTS_PATH_PROJECT="$RACINE"/projects/"$PROJECT"
  local date_before date_after 
  date_before=$(date -r "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  pluginsbefore=$(yq 'select(.plugins)|.plugins|keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo "Nb plugins avant maj : ${#pluginsbefore[@]}"

  nano "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml

  date_after=$(date -r "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  if [ "$date_after" != "$date_before" ]; then
     [ "$DEBUG" = true ] && echo "il y a eu des maj..."
    # check validity .yml 
    yq "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml >/dev/null || exit 1
    pluginsafter=$(yq 'select(.plugins) |.plugins| keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
    [ "$DEBUG" = true ] && echo "Nb plugins apres maj : ${#pluginsafter[@]}"
    # on ne récupere que les plugins uniques donc uniquement ceux supprimés et non aussi ceux ajoutés !
    plugins_suppress=($(echo "${pluginsbefore[@]}" "${pluginsafter[@]}" "${pluginsafter[@]}" | tr ' ' '\n' | sort | uniq -u))
    [ "$DEBUG" = true ] && echo "nb plugins à supprimmer: ${#plugins_suppress[@]}"
    for key in "${!plugins_suppress[@]}"; do    
      # skip first entry -  
      [[ ${plugins_suppress[$key]} == '-' ]] && continue
      echo "A supprimmer: $key ${plugins_suppress[$key]}"
      suppress_plugin "$PROJECT" "${plugins_suppress[$key]}"
    done
    config_check "$PROJECT"
    update_codebase "$PROJECT"
    success Code base updated
  else
    echo "Pas de modification de la liste des plugins"
  fi  

  info End

}

function update_repo () {  
  
  info Start    
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1 
  PLUGINS=$(yq 'select(.plugins) |.plugins| keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && info PLUGINS "$PLUGINS"
  for PLUGIN in $PLUGINS; do    
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    info "Check plugin: $PLUGIN"
    if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then	   
      upgrade_plugin "$PROJECT" "$PLUGIN"
    else
      import_plugin "$PROJECT" "$PLUGIN"
    fi
  done

  info End

}

function upgrade_plugin () {
  
  info Start 
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"
  cd "$DEPOT_MODULES/$PLUGIN" || exit 1
   
  set_plugin "$PROJECT" "$PLUGIN"
  
  git checkout --quiet $BRANCH_PLUGIN ||check_command Error branch "$BRANCH_PLUGIN" not exists

  if [[ $PLUGIN_VERSION == null ]]; then    

    # SITEREMOTE=$(git remote | grep 'upstream')
    # [ $SITEREMOTE != 'upstream' ] && error=1 && echo "$red site remote upstream missing $black" && exit 1
    
    git fetch --quiet upstream || check_command "Error git fetch upstream"
    git show-ref --verify --quiet refs/heads/"$BRANCH_UPSTREAM" ||check_command "Error  git show-ref ref/heads/$BRANCH"   
     
    BRANCHREMOTE=$(git rev-parse --abbrev-ref "$BRANCH_UPSTREAM@{upstream}")
    [ "$DEBUG" = true ]&&echo "branche remote : $BRANCHREMOTE" 
     
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse @{u})
    BASE=$(git merge-base @ @{u})
    
    [ "$DEBUG" = true ]&&echo LOCAL:  "$LOCAL"
    [ "$DEBUG" = true ]&&echo REMOTE: "$REMOTE"
    [ "$DEBUG" = true ]&&echo BASE:   "$BASE"

    if [ "$LOCAL" = "$REMOTE" ]; then
      success "$PLUGIN branche $BRANCH up-to-date with remote $BRANCHREMOTE"
    elif [ "$LOCAL" = "$BASE" ]; then           
      warn "$BRANCH_UPSTREAM need to pull from remote $BRANCHREMOTE" 
      # git fetch --quiet upstream
      # [ $? -ne 0 ] && error=1 &&  echo "$red error git fetch --quiet upstream $black" && exit 1
      if [ "$PLUGIN_UPGRADE_AUTO" == true ];then        
        info "Mise à jour automatique du plugin $PLUGIN"
        git fetch --quiet upstream || check_command "Error git checkout --quiet upstream"
        git checkout --quiet $BRANCH_UPSTREAM || check_command "Error git checkout --quiet $BRANCH_UPSTREAM"
        git merge --quiet --ff-only upstream/$BRANCH_UPSTREAM || check_command "Error git merge --quiet --ff-only upstream/$BRANCH_UPSTREAM"
         
        if [ $LOCALDEV != null ]; then 
          EXISTS=$(git show-ref refs/heads/"$LOCALDEV")
          if [[ -z $EXISTS ]]; then
            git branch --quiet $LOCALDEV $BRANCH_UPSTREAM || check_command Error git branch --quiet "$LOCALDEV" "$BRANCH_UPSTREAM"
          fi
          git checkout --quiet "$LOCALDEV" || check_command Error git checkout "$LOCALDEV"
          git rebase --quiet "$BRANCH_UPSTREAM"
          if [ $? -eq 0 ]; then
            success "$LOCALDEV git rebase $BRANCH_UPSTREAM successfull"
          else 
            error "error $LOCALDEV git rebase $BRANCH_UPSTREAM" && exit 1
          fi
        fi
      fi
    elif [ "$REMOTE" == "$BASE" ]; then           
        warn "$BRANCH_UPSTREAM need to push to remote $BRANCHREMOTE"
    else           
        error "$BRANCH_UPSTREAM diverged with remote $BRANCHREMOTE !!!" && exit 1
    fi
  else
    # cas pinned version     
    # check contains 

    if [[ 0 -eq $(git merge-base --is-ancestor "$PLUGIN_VERSION" HEAD) ]]; then
      success "$PLUGIN / $BRANCH_PLUGIN contains pinned version $PLUGIN_VERSION"
     else
      error=1
      error "$BRANCH_PLUGIN does not contains pinned version $PLUGIN_VERSION"
      exit
    fi

    git reset --hard "$PLUGIN_VERSION" || check_command Error git reset --hard "$PLUGIN_VERSION"
  fi

  info End
}

function import_plugin () {

  info Start  
  
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"
  [ "$DEBUG" = true ]&& info "debug $FUNCNAME $PROJECT $PLUGIN $DEPOT_MODULES"
  set_plugin "$PROJECT" "$PLUGIN" 
  cd "$DEPOT_MODULES" || exit 1  
  git clone  "$SOURCE" "$PLUGIN" --quiet
  [ $? -ne 0 ] && erreur git clone "$SOURCE" "$PLUGIN" && exit 9

  cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
  # if plugin contains submodules initialize and update
  if [ -d .gitmodules ]; then
    git submodules --init
    [ $? -ne 0 ] && error erreur git submodules init && exit 12
  fi
  git remote rename origin upstream || check_command Error git remote rename origin  upstream
    
  git checkout "$BRANCH_UPSTREAM" --quiet
  if [[ $? -ne 0 ]]; then
    echo creation branche "$BRANCH_UPSTREAM"
    git branch '$BRANCH_UPSTREAM" remotes/upstream/"$BRANCH_UPSTREAM' --quiet || check_command "Error git branch --quiet remotes/upstream/$BRANCH_UPSTREAM"
    git checkout "$BRANCH_UPSTREAM" --quiet || check_command Error git checkout --quiet "$BRANCH_UPSTREAM"
  fi
  
  if [[ "$PLUGIN_VERSION" != null ]]; then
    [ "$DEBUG" = true ]&&echo PLUGIN_VERSION: "$PLUGIN_VERSION"
    git checkout "$PLUGIN_VERSION" --quiet || (error "$PLUGIN_VERSION is not tag nor commit of plugin $PLUGIN" && exit 1)
    BRANCH_PLUGIN="$PLUGIN_VERSION"
  elif [[ "$LOCALDEV" != null ]]; then
    if [[ "$(git branch)" != *"${LOCALDEV}"* ]]; then
      echo "Create Branch ${LOCALDEV} from ${BRANCH_UPSTREAM}"
      git branch "${LOCALDEV}" "${BRANCH_UPSTREAM}" || (error "Error git branch ${LOCALDEV} ${BRANCH_UPSTREAM}" && exit 1)  
      success "Branch localdev $LOCALDEV created "
    fi
    BRANCH_PLUGIN="$LOCALDEV"
  else
     BRANCH_PLUGIN="$BRANCH_UPSTREAM"  
  fi
  # verification avant de quitter
  set_plugin "$PROJECT" "$PLUGIN"
  git checkout "$BRANCH_PLUGIN" --quiet || check_command "Error git checkout $BRANCH_PLUGIN"
  
  # if [[ $LOCALDEV != null ]]; then
  #   git branch "$LOCALDEV" "$BRANCH_UPSTREAM"  --quiet
  #   [ $? -ne 0 ] && echo "$red erreur git checkout --quiet $BRANCH_UPSTREAM $black" && exit 1
  #   echo "$green branch localdev $LOCALDEV created $black" && exit 1
  # fi
  
  # if [[ $PLUGIN_VERSION != null ]]; then
  #     set_version
  # fi 
  
  [ "$DEBUG" = true ]&& echo "$PLUGIN" type: "$TYPE" dir: "$DIR"
  success "Plugin cloned under name $PLUGIN in local repo $DEPOT_MODULES"
  
  info End
}

function set_plugin () {  

  [ "$DEBUG" == true ] && info Start "$FUNCNAME" "$PLUGIN"
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"
 
  SOURCE=$(yq .plugins."$PLUGIN".source "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)  
  BRANCH_UPSTREAM=$(yq .plugins."$PLUGIN".branch "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)  
  PLUGIN_VERSION=$(yq .plugins."$PLUGIN".version "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  LOCALDEV=$(yq .plugins."$PLUGIN".localdev "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  #if LOCALDEV not defined set to null
  if [[ "$PLUGIN_VERSION" != null ]]; then    
    BRANCH_PLUGIN="$PLUGIN_VERSION"
    [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN  from PLUGIN_VERSION not null: $PLUGIN_VERSION"
  elif [[ "$LOCALDEV" != 'null' ]]; then
    BRANCH_PLUGIN="$LOCALDEV"
    [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN from LOCALDEV not null: $LOCALDEV"
  else
    BRANCH_PLUGIN="$BRANCH_UPSTREAM"  
    [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN from default plugin's branch: $BRANCH_UPSTREAM"
  fi  
  if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then
    cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
    git checkout "$BRANCH_PLUGIN" --quiet || check_command Error git checkout "$BRANCH_PLUGIN"
    BRANCH_PLUGIN_SHA1=$(git rev-parse HEAD)
  fi
  # DIR inclusion

  ss=${PLUGIN#*-}
  NOM=${PLUGIN#*_}
  TYPE=${ss%%_*}

# le fichier components.json permet de determiner le reprtoire de destination a partir du nom du plugin
# pour convertir au format yaml : yq -oy components.json > components.yml

  #DIR=$(jq .plugintypes.$TYPE $RACINE/components.json | tr -d '"') 
  
  DIR=$(yq ".plugintypes.$TYPE" "$RACINE"/components.yml)
  if [[ $DIR == 'null' ]];
    then error=1 && error "Prefixe $TYPE  unkown" exit 1    
  fi

  [ "$DEBUG" = true ] && echo "  PLUGIN: $PLUGIN"   
  [ "$DEBUG" = true ] && echo "  BRANCH_UPSTREAM: $BRANCH_UPSTREAM"
  [ "$DEBUG" = true ] && echo "  LOCALDEV: $LOCALDEV"  
  [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN"
  [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN_SHA1: $BRANCH_PLUGIN_SHA1"
  [ "$DEBUG" = true ] && echo "  SOURCE: $SOURCE"
  [ "$DEBUG" = true ] && echo "  PLUGIN VERSION : $PLUGIN_VERSION"
  [ "$DEBUG" = true ] && echo "  DIR : $DIR"

  [ "$DEBUG" = true ] && info End
} 

function subrepo_plugin ()  {
  
  info Start 
  
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  [ -z "$1" ]&& error project param PLUGIN missing && exit
  PROJECT="$1"
  PLUGIN="$2"
  MSG="$3"
  
  set_plugin "$PROJECT" "$PLUGIN"

  cd "$MOODLE_SRC"
  if [ ! -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; then
    mkdir -p "$MOODLE_SRC"/"$DIR"/"$NOM"
  fi
  rsync -a "$DEPOT_MODULES"/"$PLUGIN"/* "$MOODLE_SRC"/"$DIR"/"$NOM"/
  echo "    branch = $BRANCH_PLUGIN" > "$MOODLE_SRC"/"$DIR"/"$NOM"/.gitrepo
  echo "    commit = $BRANCH_PLUGIN_SHA1" >> "$MOODLE_SRC"/"$DIR"/"$NOM"/.gitrepo
  git add . || check_command git add .
  git commit -m "$MSG" --quiet || check_command Error git commit "$MSG"
  
  info End
}

function update_codebase () {

  info Start 
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  # Etape 1 met à jour le depot local de plugin
  update_repo "$PROJECT"
  # Etape 2 met à jour la base de code
    
  cd "$MOODLE_SRC" || exit 1
  git checkout "$PROJECT_BRANCH" --quiet || (error git checkout "$PROJECT_BRANCH" && exit 1)

  PLUGINS=$(yq 'select(.plugins) |.plugins|keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && info PLUGINS "$PLUGINS"
  for PLUGIN in $PLUGINS; do
    [[ "$PLUGIN" =~ ^\-.* ]] && continue      
    set_plugin "$PROJECT" "$PLUGIN"  
    info "Check: $PLUGIN branch: $BRANCH_PLUGIN"  
    cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1

  # BRANCH_UPSTREAM branche du plugin dans le depot source
  # BRANCH_PLUGIN branche à utiliser 
  # = BRANCH_UPSTREAM quand il n'y a pas de de local
  # = LOCALDEV  branch de dev local  
  # = PLUGIN_VERSION quand il existe une version explicite du plugin la branche BRANCH_PLUGIN  est crée à ce commit lors de création ou de la mise à jour
    
    git checkout "$BRANCH_PLUGIN" --quiet || check_command git checkout "$BRANCH_PLUGIN"
  
    LOCAL=$(git rev-parse @)

    if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; then
    # module already installed
      cd "$MOODLE_SRC"/"$DIR"/"$NOM" || exit 1     
      #for sha1 complet -c11-50 | cut -c11-50
      #COMMIT=$(grep .gitrepo -e 'commit = ') 
      [[ $(grep .gitrepo -e 'commit = ') =~ ^.*commit' = '([a-f0-9].*)$ ]] && COMMIT="${BASH_REMATCH[1]}" 
            
      if [[ "$COMMIT" == "$LOCAL" ]]; then    
        # MOD='OK'
        success "$PLUGIN est installe dans $MOODLE_SRC/$DIR/$NOM et est à jour OK"
      else     
        # MOD='UPD'
        warn "$PLUGIN est installe dans $MOODLE_SRC/$DIR/$NOM mais n est pas à jour UPD"          
        cd  "$MOODLE_SRC" || exit 1         
        subrepo_plugin "$PROJECT" "$PLUGIN" "Mise à jour de $PLUGIN"
        success "$PLUGIN mis à jour dans le répertoire $DIR"  
      fi
    else      
      # MOD='ADD' 
      warn "$PLUGIN missing in $MOODLE_SRC/$DIR/$NOM. ADD"
      info "$PLUGIN type: $TYPE path: $DIR branch: $BRANCH_PLUGIN"
      subrepo_plugin "$PROJECT" "$PLUGIN" "Add $PLUGIN / $BRANCH_PLUGIN dans le répertoire $DIR"
      info "$PLUGIN / $BRANCH_PLUGIN ajouté dans le répertoire $DIR" 
    fi
  
  done

 info End

}

function release () {

info Start 
error=0
[ -z "$1" ]&& error project param PROJECT missing && exit
PROJECT="$1"
info "Project $PROJECT Branch src Moodle: $PROJECT_BRANCH"

load_cnf "$PROJECT" || exit 1

# $2 MSG for new release
info New release: "$NEWRELEASE" 
NEWRELEASE="$PROJECT_BRANCH"-$(date +%Y.%m.%d@%Hh%M) 
MSG="${2:-${NEWRELEASE}}"
#[ -z "${2}" ] && MSG="Release: $NEWRELEASE" || MSG="$2"
info MSG: "$MSG"
cd "$MOODLE_SRC" || exit 1
[ "$DEBUG" = true ] && echo PROJECT_BRANCH: "$PROJECT_BRANCH"
git checkout "$PROJECT_BRANCH" --quiet || check_command git checkout "$PROJECT_BRANCH"  
git commit --allow-empty -m "$MSG" || check_command git commit --allow-empty -m "$MSG"
git tag -a "$NEWRELEASE" -m "" || check_command git tag -a "$NEWRELEASE"

# create <PROJECT>.lock
project_lock "$PROJECT"

if [[ "$MOODLE_UPDATE_ORIGIN" == 'Y' ]]; then
  info "Update $PROJECT_BRANCH in remote repository origin"
  git push origin "$PROJECT_BRANCH" || check_command git push origin "$PROJECT_BRANCH"
fi

info End
}

function project_lock () {

  info Start 
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"  
  error=0
  #load_cnf "$PROJECT"  && echo conf $PROJECT successfully loaded || exit
  cd "$PROJECTS_PATH"/"$PROJECT" || exit 1
  # create "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  [ -f "$PROJECT".lock ] && rm "$PROJECT".lock 
  cp "$PROJECT".yml "$PROJECT".lock

  cd "$MOODLE_SRC" || exit 1
  [ "$DEBUG" = true ] && echo "PROJECT_BRANCH: $PROJECT_BRANCH"
  git checkout "$PROJECT_BRANCH" --quiet
  [ "$DEBUG" = true ] && echo $(git rev-parse --abbrev-ref HEAD) $(git rev-parse --short HEAD)
  moodlebranch=$(git rev-parse --abbrev-ref HEAD) yq -i '.moodle.branch=strenv(moodlebranch)' $PROJECTS_PATH/$PROJECT/$PROJECT.lock 
  moodlesha1=$(git rev-parse --short HEAD) yq -i '.moodle.version=strenv(moodlesha1)' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock 

  PLUGINS=$(yq 'select(.plugins)|.plugins|keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS "$PLUGINS"
  for PLUGIN in $PLUGINS; do     
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    [ "$DEBUG" = true ] &&echo "Check plugin: $PLUGIN"
    set_plugin "$PROJECT" "$PLUGIN"
    [[ $(cat "$MOODLE_SRC"/"$DIR"/"$NOM"/.gitrepo | grep 'commit') =~ .*=.([0-9a-z]+) ]] && commit="${BASH_REMATCH[1]}" 
    pathenv=".plugins.$PLUGIN" commit=${commit:0:7} yq -i 'eval(strenv(pathenv)).version = strenv(commit)' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  done
  info End "$PROJECT"
  return $error
}

function suppress_plugin () {

  info Start 
  error=0
  [ -z "$1" ]&& error project param PROJECT missing && exit
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN=$2

  echo " Suppression du plugin ${PLUGIN}" 
        
  if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Suppression du plugin ${PLUGIN}" 10 60) 
  then

    # DIR inclusion

    ss=${PLUGIN#*-}
    NOM=${PLUGIN#*_}
    TYPE=${ss%%_*}

    # le fichier components.json permet de determiner le reprtoire de destination a partir du nom du plugin
    # pour convertir au format yaml : yq -oy components.json > components.yml
    #DIR=$(jq .plugintypes.$TYPE $RACINE/components.json | tr -d '"') 
  
    DIR=$(yq ".plugintypes.$TYPE" "$RACINE"/components.yml)
    if [[ $DIR == 'null' ]];
      then error=1 && error "Prefixe $TYPE unkown" exit 1    
    fi

    if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; 
    then
      cd "$MOODLE_SRC" || exit 1      
      git rm -r  "$MOODLE_SRC"/"$DIR"/"$NOM" || check_command Error git rm -r  "$MOODLE_SRC"/"$DIR"/"$NOM"
      git commit -m "Suppress plugin $PLUGIN" --quiet || check_command git commit -m "Suppress plugin $PLUGIN"      
      success "$PLUGIN deleted in codebase"  
      echo -e "Press any key \n"
      read -rn 1 c
      sortie=0
    else
      warn "Plugin $PLUGIN not present nothing to do!"     
    fi
  else
   echo "Abandon !"  
  fi

info End
}


function nothingtodo () {
  error=0
  export sortie
  echo 'nothing to do..'
  sortie=0
  echo -e "Press any key \n"
  read -nr 1 c
 }

function help () {
  info Start 
 # pandoc -s -f markdown -t man README.md | groff -T utf8 -man | less
  cat README.md
  info End
}